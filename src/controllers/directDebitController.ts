/**
 * API-XenditLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  BindingCreateCustomerRequest,
  bindingCreateCustomerRequestSchema,
} from '../models/bindingCreateCustomerRequest';
import {
  BindingCreatePaymentMethodRequest,
  bindingCreatePaymentMethodRequestSchema,
} from '../models/bindingCreatePaymentMethodRequest';
import {
  BindingInitiateAccountAuthorizationRequest,
  bindingInitiateAccountAuthorizationRequestSchema,
} from '../models/bindingInitiateAccountAuthorizationRequest';
import {
  BindingValidateOTPForLinkedAccountTokenRequest,
  bindingValidateOTPForLinkedAccountTokenRequestSchema,
} from '../models/bindingValidateOTPForLinkedAccountTokenRequest';
import {
  PaymentOneTimePaymentWOOTPRequest,
  paymentOneTimePaymentWOOTPRequestSchema,
} from '../models/paymentOneTimePaymentWOOTPRequest';
import {
  PaymentOneTimePaymentWOTPRequest,
  paymentOneTimePaymentWOTPRequestSchema,
} from '../models/paymentOneTimePaymentWOTPRequest';
import {
  PaymentRecurringPaymentsRequest,
  paymentRecurringPaymentsRequestSchema,
} from '../models/paymentRecurringPaymentsRequest';
import {
  PaymentValidateOTPOneTimePaymentWOTPRequest,
  paymentValidateOTPOneTimePaymentWOTPRequestSchema,
} from '../models/paymentValidateOTPOneTimePaymentWOTPRequest';
import {
  SuccessfullyDeletedALinkedAccountToken,
  successfullyDeletedALinkedAccountTokenSchema,
} from '../models/successfullyDeletedALinkedAccountToken';
import {
  SuccessfullyInitiatedAnAuthorizationRequest,
  successfullyInitiatedAnAuthorizationRequestSchema,
} from '../models/successfullyInitiatedAnAuthorizationRequest';
import {
  SuccessfullyRetrievedAccessibleAccountsForALinkedAccountTokenCopy,
  successfullyRetrievedAccessibleAccountsForALinkedAccountTokenCopySchema,
} from '../models/successfullyRetrievedAccessibleAccountsForALinkedAccountTokenCopy';
import { array, string } from '../schema';
import { BaseController } from './baseController';

export class DirectDebitController extends BaseController {
  /**
   * A customer object is required in order to link a payment method for direct debit. This allows you to
   * easily link and track payment methods and transactions.
   *
   * @param body
   * @return Response from the API call
   */
  async bindingCreateCustomer(
    body: BindingCreateCustomerRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/customers');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      body: [body, bindingCreateCustomerRequestSchema],
    });
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Account linking is required before performing direct debits.
   *
   * Account authorizations are represented by linked account tokens. This endpoint initializes the
   * authorization process and linked account token creation.
   *
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async bindingInitiateAccountAuthorization(
    contentType: string,
    body: BindingInitiateAccountAuthorizationRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SuccessfullyInitiatedAnAuthorizationRequest>> {
    const req = this.createRequest('POST', '/linked_account_tokens/auth');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      contentType: [contentType, string()],
      body: [body, bindingInitiateAccountAuthorizationRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    return req.callAsJson(
      successfullyInitiatedAnAuthorizationRequestSchema,
      requestOptions
    );
  }

  /**
   * Account linking for BRI requires an OTP to proceed.
   *
   * Upon successful initialization, the bank will send an OTP to the customer's registered mobile number
   * directly. This endpoint validates the OTP with the bank.
   *
   *
   *
   * @param linkedAccountTokenId
   * @param contentType
   * @param body
   * @return Response from the API call
   */
  async bindingValidateOTPForLinkedAccountToken(
    linkedAccountTokenId: string,
    contentType: string,
    body: BindingValidateOTPForLinkedAccountTokenRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SuccessfullyInitiatedAnAuthorizationRequest>> {
    const req = this.createRequest('POST');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      linkedAccountTokenId: [linkedAccountTokenId, string()],
      contentType: [contentType, string()],
      body: [body, bindingValidateOTPForLinkedAccountTokenRequestSchema],
    });
    req.header('Content-Type', mapped.contentType);
    req.json(mapped.body);
    req.appendTemplatePath`/linked_account_tokens/${mapped.linkedAccountTokenId}/validate_otp`;
    return req.callAsJson(
      successfullyInitiatedAnAuthorizationRequestSchema,
      requestOptions
    );
  }

  /**
   * This endpoint returns a list of bank accounts accessible by the linked account token. The response
   * information from this endpoint is required for creation of payment method.
   *
   * For BPI, it is possible to have more than one accessible account.
   *
   * @param linkedAccountTokenId
   * @param contentType
   * @return Response from the API call
   */
  async bindingRetreiveAccessibleAccountsCopy(
    linkedAccountTokenId: string,
    contentType: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SuccessfullyRetrievedAccessibleAccountsForALinkedAccountTokenCopy[]>> {
    const req = this.createRequest('GET');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      linkedAccountTokenId: [linkedAccountTokenId, string()],
      contentType: [contentType, string()],
    });
    req.header('Content-Type', mapped.contentType);
    req.appendTemplatePath`/linked_account_tokens/${mapped.linkedAccountTokenId}/accounts`;
    return req.callAsJson(
      array(
        successfullyRetrievedAccessibleAccountsForALinkedAccountTokenCopySchema
      ),
      requestOptions
    );
  }

  /**
   * Payment methods enable you to abstract sources of funds and use them for making direct debit
   * payments or recurring payments. Currently, only supports linked accounts.
   *
   * @param body
   * @return Response from the API call
   */
  async bindingCreatePaymentMethod(
    body: BindingCreatePaymentMethodRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/payment_methods');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      body: [body, bindingCreatePaymentMethodRequestSchema],
    });
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Create a single debit to pull funds from the end customer's account using an active payment method
   * without requiring an OTP.
   *
   *
   *
   * @param idempotencyKey
   * @param body
   * @return Response from the API call
   */
  async paymentOneTimePaymentWOOTP(
    idempotencyKey: string,
    body: PaymentOneTimePaymentWOOTPRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/direct_debits');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      idempotencyKey: [idempotencyKey, string()],
      body: [body, paymentOneTimePaymentWOOTPRequestSchema],
    });
    req.header('idempotency-key', mapped.idempotencyKey);
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Create a single debit to pull funds from the end customer's account using an active payment method.
   *
   *
   *
   * @param idempotencyKey
   * @param body
   * @return Response from the API call
   */
  async paymentOneTimePaymentWOTP(
    idempotencyKey: string,
    body: PaymentOneTimePaymentWOTPRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/direct_debits');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      idempotencyKey: [idempotencyKey, string()],
      body: [body, paymentOneTimePaymentWOTPRequestSchema],
    });
    req.header('idempotency-key', mapped.idempotencyKey);
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Validate the OTP provided by end customer via this endpoint to complete the transaction when OTP is
   * enabled.
   *
   * @param directDebitId
   * @param body
   * @return Response from the API call
   */
  async paymentValidateOTPOneTimePaymentWOTP(
    directDebitId: string,
    body: PaymentValidateOTPOneTimePaymentWOTPRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      directDebitId: [directDebitId, string()],
      body: [body, paymentValidateOTPOneTimePaymentWOTPRequestSchema],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/direct_debits/${mapped.directDebitId}/validate_otp`;
    return req.call(requestOptions);
  }

  /**
   * Recurring payments allow you to use the auto debit feature in direct debit to pull funds from your
   * customers bank account on a scheduled basis.
   *
   * Currently only supported for BRI Direct Debit.
   *
   * @param idempotencyKey
   * @param body
   * @return Response from the API call
   */
  async paymentRecurringPayments(
    idempotencyKey: string,
    body: PaymentRecurringPaymentsRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST', '/recurring_payments');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      idempotencyKey: [idempotencyKey, string()],
      body: [body, paymentRecurringPaymentsRequestSchema],
    });
    req.header('idempotency-key', mapped.idempotencyKey);
    req.json(mapped.body);
    return req.call(requestOptions);
  }

  /**
   * Unlinks or unbinds a successfully linked account token.
   *
   *
   *
   * @param linkedAccountTokenId
   * @param contentType
   * @return Response from the API call
   */
  async bindingUnlinkLinkedAccountTokenCopy(
    linkedAccountTokenId: string,
    contentType: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SuccessfullyDeletedALinkedAccountToken>> {
    const req = this.createRequest('DELETE');
    req.baseUrl('Server 1');
    const mapped = req.prepareArgs({
      linkedAccountTokenId: [linkedAccountTokenId, string()],
      contentType: [contentType, string()],
    });
    req.header('Content-Type', mapped.contentType);
    req.appendTemplatePath`/linked_account_tokens/${mapped.linkedAccountTokenId}`;
    return req.callAsJson(
      successfullyDeletedALinkedAccountTokenSchema,
      requestOptions
    );
  }
}
